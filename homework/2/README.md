# Домашна работа №2

Домашна работа №2 включва задачи свързани с нишки, процеси, тръби за комуникация между процеси и системните функции за работа с тях, които сме разглеждали до момента - `pthread_create`, `pthread_join`, `pthread_mutex_lock`, `pthread_mutex_unlock`, `fork`, `pipe`, `dup` и други. Състои се от 2 задачи, като всяка задача се оценява максимално с 200 точки. Получавате отделна оценка за всяка задача. Формулата за оценките е:

```plaintext
оценка = 2 + (точки / 50)
```

Срокът на домашната работа е **до 11.01.2025 (Неделя), 23:59:59**.

## ⚠️ ВАЖНО ⚠️

Напомням ви, че домашното ще бъде проверявано за плагиатство! Това включва и използването
на text-transformer невронни мрежи за написването решенията си, като ChatGPT, GitHub
Copilot и подобни услуги за генериране на код. Ако случайно сте почнали домашното
и casually сте се възползвали от такива услуги, това, което искам да направите е:

- Да спрете Copilot/каквото друго ползвате
- Да изтриете целия код, който имате досега
- Да почнете начисто и да си работите самостоятелно, като всякакъв код, копиран
  от някъде, да бъде ясно деклариран като коментар и по време на евентуална защита.

Имайте предвид, че невронните мрежи не са магия - реално са доста детерминистични
в изхода си и генерират доста сходен код, който после лесно се забелязва при проверката
за еднаквост на домашните ви.

Също така, важно е да отбележа, че преди крайния срок всякакво споделяне на решения
е забранено.

Това включва:

- Да пратите решението си на някой друг.
- Да го покажете на другарче, за да "почерпи идеи".
- Да го сложите някъде публично преди крайния срок.

От друга страна, не се притеснявайте да напишете най-простия възможен код, понеже
"други хора ще предадат същото решение". Това също се разпознава лесно, и разбира
се, няма да сметна, че сте преписвали. Пишете най-добрия код, на който сте способни,
не споделяйте решенията си и няма да има причина да се притеснявате, че ще помислим,
че сте преписвали.

Ако ви е нужна помощ с каквото и да е - разбиране на условието, кодът, качването
му и т.н., не се притеснявайте да се свържете с мен в по
имейл на `ibozhilov@elsys-bg.org`.


---


# Задача 1: Умножение на матрици с pthreads (200 точки)



## Описание на задачата

Целта на задачата е да се имплементира паралелно умножение на матрици, използвайки **pthreads** библиотеката. Tрябва да разделите изчисленията между няколко нишки, като всяка нишка ще отговаря за изчисляването на един или повече редове от резултатната матрица.

---

## Изисквания

### Матрици

- Матрица \( A \): \( M x N \) от тип `int`
- Матрица \( B \): \( N x P \) от тип `int`
- Резултатна матрица \( C \): \( M x P \) от тип `int`

### Входни данни

- Матриците \( A \) и \( B \) ще се подават чрез текстови файлове:
  - Файлът за матрица \( A \) съдържа \( M x N \) числа, подредени в редове и разделени със ";".
  - Файлът за матрица \( B \) съдържа \( N x P \) числа, подредени по същия начин.
  - Първите редове от файловете оказват размерността на матриците, като двете измерения са разделени с ";".
- Имената на файловете за вход ще се подават като аргументи на командния ред.
- Примерно съдръжание на входните файлове:
```plaintext
4;4
9;5;1;0
7;5;0;1
3;6;10;4
0;10;3;6
```


### Аргументи на командния ред

Програмата трябва да приема следните аргументи:
- `a.txt` - файл с матрица \( A \)
- `b.txt` - файл с матрица \( B \)
- `c.txt` - файл, където да се зашише матрица \( C \)
- `t` - брой нишки, които ще се използват за изчисления
- Примерно изпълнение на програмата:
```plaintext
./matmul a.txt b.txt c.txt 4
```

### Изход

- Резултатната матрица \( C \) трябва да се запише в изходен файл `c.txt` във формат, аналогичен на входните файлове.
---

## Какво трябва да направите

1. **Четене и записване на матрици**
   - Във файла `matmul.c` има функции, които можете да използвате за четене или записване на матрици от/във файлове. Също така има функции за заделяне и освобождаване на памет за съответните матрици.

2. **Създаване на нишки**
   - Разделете изчисленията на матрица \( C \) между нишките, така че всяка нишка да изчислява определен брой редове.
   - Използвайте структура, за да предавате необходимите данни на всяка нишка.

   ```c
   struct ThreadData {
       int start_row;
       int end_row;
       int **A;
       int **B;
       int **C;
       int N; // Общият брой колони на A (и редове на B)
       int P; // Броят на колоните на B
   };

3. **Умножение на матрици**
  - Вашата програма трябва да проверява дали размерността на матриците е правилна. За да може да се извърши умножение на матрици броя на колоните на първата матрица трябва да е равен на броя на редовете на втората. Ако това не е вярно за подадените входни данни, програмата трябва да изведе "**Wrong dimensions**".
  - Самото умножение на матриците става по следния начин:
  

  $$
  \mathbf{C} = \mathbf{A} \cdot \mathbf{B}, където \quad c_{ij} = \sum_{k=1}^{n} a_{ik} b_{kj}
  $$

  - Допълнително обяснение на метода за умножение на матрици можете да намерите [тук](https://en.wikipedia.org/wiki/Matrix_multiplication).

4. **Кодът, който трябва да нашишете**
  - Файлът `matmul.c` представлява примерен шаблон за програмата, която трябва да напишете. В него са дефинирани спомагателни функции, които можете да ползвате. Реалната имплементация на параленото умножение на матрици трябва да напишете между коментарите **START HERE** и **END HERE**. Разбира се, не е необходимо да ползвате шаблона и може да напишете цялата програма сами, стига умножението да се изпълнява правилно и всички изисквания да са спазени.

5. **Проверка на резултатите**
 - За да проверите дали вашата програма изпълнява умножението правилно, можете да ползвате следния [линк](https://matrix.reshish.com/multiplication.php).
 - В директорията `data` има примерни входни файлове с матрици, върху които можете да тествате вашият код. 

---


# Задача 2: `sh (extended)` (200 точки)

## Описание на задачата

Задача 2 цели да разшири `sh` задачата от практическо занятие №3. Целта на задачата беше да се реализира прост команден интерпретатор - `sh`. (виж [тук](https://github.com/os-tues/os-tues-2024-2025-11v/tree/main/practice/03-processes)).

В разширеното условие, трябва да направите поддръжка за тръби (pipes), както и подръжка за подаване на аргументи към командите (виж [тук](https://github.com/os-tues/os-tues-2024-2025-11v/blob/main/practice/03-processes/Code/src/shell_args.c)).

## Изисквания

- При стартиране на програмата, тя започва да чете редове от стандартния вход и да ги интерпретира. За тази цел програмата трябва да раздели командния ред на думи, като за разделител се използва интервал (`" "`). Tова може да се реализира чрез функцията `strtok`.

  Например, ако на стандартния вход се напише следния ред:

  ```bash
  shell> ls | grep example
  ```
  то командния интерпретатор трябва изпълни първо ls командата и след това да пренасочи стандартния ѝ изход към grep командата.

- Трябва да се поддържат n-наброй подавания с тръби - т.е. да могат да се поддържат команди от типа:
  ```bash
  shell> ls | grep .txt | cowsay
  shell> ls | grep .txt | grep a | cowsay
  ```

**_NOTE:_** За мое улеснение при проверка на задачите, моля текста, който излиза в началото на реда при писане на команда, да е `"shell>"`, както е в примерните от практическо занятие №3.
